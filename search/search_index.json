{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Ensembl Python general-purpose utils","text":"<p>Centralise generic Python utils used by other project within Ensembl design to facilitate frequent tasks such as input file path checks, archive files IO manipulation or logging setup, among others.</p>"},{"location":"#contents","title":"Contents","text":"<p>Check out installation section for further information on how to install the project.</p> <ol> <li>Install</li> <li>Code of Conduct</li> <li>Coverage report</li> <li>Code reference</li> </ol>"},{"location":"#license","title":"License","text":"<p>Software as part of Ensembl Python general-purpose utils is distributed under the Apache-2.0 License.</p>"},{"location":"code_of_conduct/","title":"Code of Conduct","text":"<p>The Ensembl project is built on a foundation of collaboration, mutual respect and equality with a diverse and global community. We do not condone discrimination or abusive behaviour of any form. We encourage participation and engagement for everyone, in a professional manner, and wish all members of our community to adhere to the same principles.</p>"},{"location":"install/","title":"How to install this repository","text":"<p>This Python library only requires Python 3.10+ to work. However, it is likely that most modules and functionalities will be compatible with Python 3.9 as well.</p>"},{"location":"install/#basic-installation","title":"Basic installation","text":"<p>This library is publicly available in PyPI so it can be easily installed with your favourite Python dependency and packaging management tool, e.g.</p> <pre><code>pip install ensembl-utils\n</code></pre>"},{"location":"install/#development-oriented-installation","title":"Development-oriented installation","text":"<p>If you want to install this library in editable mode, we suggest you to do so via Python's virtual environment module (venv):</p> <pre><code>python -m venv &lt;VIRTUAL_ENVIRONMENT_NAME&gt;\nsource &lt;VIRTUAL_ENVIRONMENT_NAME&gt;/bin/activate\ngit clone https://github.com/Ensembl/ensembl-utils.git\ncd ensembl-utils\npip install -e .[cicd,docs]\n</code></pre> <p>Note that the documentation (<code>docs</code> tag) is generated using mkdocs. For full information visit mkdocs.org.</p>"},{"location":"reference/summary/","title":"Summary","text":"<ul> <li>ensembl<ul> <li>utils<ul> <li>archive</li> <li>argparse</li> <li>logging</li> <li>rloader</li> </ul> </li> </ul> </li> </ul>"},{"location":"reference/ensembl/utils/","title":"utils","text":""},{"location":"reference/ensembl/utils/#ensembl.utils","title":"<code>ensembl.utils</code>","text":"<p>Ensembl Python general-purpose utils library.</p>"},{"location":"reference/ensembl/utils/#ensembl.utils.StrPath","title":"<code>StrPath = Union[str, os.PathLike]</code>  <code>module-attribute</code>","text":""},{"location":"reference/ensembl/utils/archive/","title":"archive","text":""},{"location":"reference/ensembl/utils/archive/#ensembl.utils.archive","title":"<code>ensembl.utils.archive</code>","text":"<p>Utils for common IO operations over archive files, e.g. tar or gzip.</p>"},{"location":"reference/ensembl/utils/archive/#ensembl.utils.archive.SUPPORTED_ARCHIVE_FORMATS","title":"<code>SUPPORTED_ARCHIVE_FORMATS = [ext for elem in shutil.get_unpack_formats() for ext in elem[1]]</code>  <code>module-attribute</code>","text":""},{"location":"reference/ensembl/utils/archive/#ensembl.utils.archive.extract_file","title":"<code>extract_file(src_file, dst_dir)</code>","text":"<p>Extracts the <code>src_file</code> into <code>dst_dir</code>.</p> <p>If the file is not an archive, it will be copied to <code>dst_dir</code>. <code>dst_dir</code> will be created if it does not exist.</p> <p>Parameters:</p> Name Type Description Default <code>src_file</code> <code>StrPath</code> <p>Path to the file to unpack.</p> required <code>dst_dir</code> <code>StrPath</code> <p>Path to the folder where to extract the file.</p> required Source code in <code>src/ensembl/utils/archive.py</code> <pre><code>def extract_file(src_file: StrPath, dst_dir: StrPath) -&gt; None:\n    \"\"\"Extracts the `src_file` into `dst_dir`.\n\n    If the file is not an archive, it will be copied to `dst_dir`. `dst_dir` will be created if it\n    does not exist.\n\n    Args:\n        src_file: Path to the file to unpack.\n        dst_dir: Path to the folder where to extract the file.\n\n    \"\"\"\n    src_file = Path(src_file)\n    extensions = {\"\".join(src_file.suffixes[i:]) for i in range(0, len(src_file.suffixes))}\n\n    if extensions.intersection(SUPPORTED_ARCHIVE_FORMATS):\n        shutil.unpack_archive(src_file, dst_dir)\n    else:\n        # Replicate the functionality of shutil.unpack_archive() by creating `dst_dir`\n        Path(dst_dir).mkdir(parents=True, exist_ok=True)\n        shutil.copy(src_file, dst_dir)\n</code></pre>"},{"location":"reference/ensembl/utils/archive/#ensembl.utils.archive.extract_file_cli","title":"<code>extract_file_cli()</code>","text":"<p>Entry-point for the <code>extract_file</code> method</p> Source code in <code>src/ensembl/utils/archive.py</code> <pre><code>def extract_file_cli() -&gt; None:\n    \"\"\"Entry-point for the `extract_file` method\"\"\"\n    parser = ArgumentParser(description=\"Extracts file to the given location.\")\n    parser.add_argument_src_path(\"--src_file\", required=True, help=\"Path to the file to unpack\")\n    parser.add_argument_dst_path(\n        \"--dst_dir\", default=Path.cwd(), help=\"Path to the folder where to extract the file\"\n    )\n    args = parser.parse_args()\n    extract_file(args.src_file, args.dst_dir)\n</code></pre>"},{"location":"reference/ensembl/utils/archive/#ensembl.utils.archive.open_gz_file","title":"<code>open_gz_file(file_path)</code>","text":"<p>Yields an open file object, even if the file is compressed with gzip.</p> <p>The file is expected to contain a text, and this can be used with the usual \"with\".</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>StrPath</code> <p>A (single) file path to open.</p> required Source code in <code>src/ensembl/utils/archive.py</code> <pre><code>@contextmanager\ndef open_gz_file(file_path: StrPath) -&gt; Generator[TextIO, None, None]:\n    \"\"\"Yields an open file object, even if the file is compressed with gzip.\n\n    The file is expected to contain a text, and this can be used with the usual \"with\".\n\n    Args:\n        file_path: A (single) file path to open.\n\n    \"\"\"\n    src_file = Path(file_path)\n    if src_file.suffix == \".gz\":\n        with gzip.open(src_file, \"rt\") as fh:\n            yield fh\n    else:\n        with src_file.open(\"rt\") as fh:\n            yield fh\n</code></pre>"},{"location":"reference/ensembl/utils/argparse/","title":"argparse","text":""},{"location":"reference/ensembl/utils/argparse/#ensembl.utils.argparse","title":"<code>ensembl.utils.argparse</code>","text":"<p>Provide an extended version of <code>argparse.ArgumentParser</code> with additional functionality.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from ensembl.util.argparse import ArgumentParser\n&gt;&gt;&gt; parser = ArgumentParser(description=\"Tool description\")\n&gt;&gt;&gt; parser.add_argument_src_path(\"--src_file\", required=True, help=\"Path to source file\")\n&gt;&gt;&gt; parser.add_server_arguments(help=\"Server to connect to\")\n&gt;&gt;&gt; args = parser.parse_args()\n&gt;&gt;&gt; args\nNamespace(host='myserver', port=3826, src_file=PosixPath('/path/to/src_file.txt'),\nurl=URL('mysql://username@myserver:3826'), user='username')\n</code></pre>"},{"location":"reference/ensembl/utils/argparse/#ensembl.utils.argparse.ArgumentParser","title":"<code>ArgumentParser</code>","text":"<p>               Bases: <code>ArgumentParser</code></p> <p>Extends <code>argparse.ArgumentParser</code> with additional methods and functionality.</p> <p>The default behaviour of the help text will be to display the default values on every non-required argument, i.e. optional arguments with <code>required=False</code>.</p> Source code in <code>src/ensembl/utils/argparse.py</code> <pre><code>class ArgumentParser(argparse.ArgumentParser):\n    \"\"\"Extends `argparse.ArgumentParser` with additional methods and functionality.\n\n    The default behaviour of the help text will be to display the default values on every non-required\n    argument, i.e. optional arguments with `required=False`.\n\n    \"\"\"\n\n    def __init__(self, *args, **kwargs) -&gt; None:\n        \"\"\"Extends the base class to include the information about default argument values by default.\"\"\"\n        super().__init__(*args, **kwargs)\n        self.formatter_class = argparse.ArgumentDefaultsHelpFormatter\n        self.__server_groups: list[str] = []\n\n    def _validate_src_path(self, src_path: StrPath) -&gt; Path:\n        \"\"\"Returns the path if exists and it is readable, raises an error through the parser otherwise.\n\n        Args:\n            src_path: File or directory path to check.\n\n        \"\"\"\n        src_path = Path(src_path)\n        if not src_path.exists():\n            self.error(f\"'{src_path}' not found\")\n        elif not os.access(src_path, os.R_OK):\n            self.error(f\"'{src_path}' not readable\")\n        return src_path\n\n    def _validate_dst_path(self, dst_path: StrPath, exists_ok: bool = False) -&gt; Path:\n        \"\"\"Returns the path if it is writable, raises an error through the parser otherwise.\n\n        Args:\n            dst_path: File or directory path to check.\n            exists_ok: Do not raise an error during parsing if the destination path already exists.\n\n        \"\"\"\n        dst_path = Path(dst_path)\n        if dst_path.exists():\n            if os.access(dst_path, os.W_OK):\n                if exists_ok:\n                    return dst_path\n                self.error(f\"'{dst_path}' already exists\")\n            else:\n                self.error(f\"'{dst_path}' is not writable\")\n        # Check if the first parent directory that exists is writable\n        for parent_path in dst_path.parents:\n            if parent_path.exists():\n                if not os.access(parent_path, os.W_OK):\n                    self.error(f\"'{dst_path}' is not writable\")\n                break\n        return dst_path\n\n    def add_argument(self, *args, **kwargs) -&gt; None:  # type: ignore[override]\n        \"\"\"Extends the parent function by excluding the default value in the help text when not provided.\n\n        Only applied to required arguments without a default value, i.e. positional arguments or optional\n        arguments with `required=True`.\n\n        \"\"\"\n        if kwargs.get(\"required\", False):\n            kwargs.setdefault(\"default\", argparse.SUPPRESS)\n        super().add_argument(*args, **kwargs)\n\n    def add_argument_src_path(self, *args, **kwargs) -&gt; None:\n        \"\"\"Adds `pathlib.Path` argument, checking if it exists and it is readable at parsing time.\n\n        If \"metavar\" is not defined, it is added with \"PATH\" as value to improve help text readability.\n\n        \"\"\"\n        kwargs.setdefault(\"metavar\", \"PATH\")\n        kwargs[\"type\"] = self._validate_src_path\n        self.add_argument(*args, **kwargs)\n\n    def add_argument_dst_path(self, *args, exists_ok: bool = True, **kwargs) -&gt; None:\n        \"\"\"Adds `pathlib.Path` argument, checking if it is writable at parsing time.\n\n        If \"metavar\" is not defined it is added with \"PATH\" as value to improve help text readability.\n\n        Args:\n            exists_ok: Do not raise an error if the destination path already exists.\n\n        \"\"\"\n        kwargs.setdefault(\"metavar\", \"PATH\")\n        kwargs[\"type\"] = lambda x: self._validate_dst_path(x, exists_ok)\n        self.add_argument(*args, **kwargs)\n\n    def add_argument_url(self, *args, **kwargs) -&gt; None:\n        \"\"\"Adds `sqlalchemy.engine.URL` argument.\n\n        If \"metavar\" is not defined it is added with \"URI\" as value to improve help text readability.\n\n        \"\"\"\n        kwargs.setdefault(\"metavar\", \"URI\")\n        kwargs[\"type\"] = make_url\n        self.add_argument(*args, **kwargs)\n\n    # pylint: disable=redefined-builtin\n    def add_server_arguments(self, prefix: str = \"\", include_database: bool = False, help: str = \"\") -&gt; None:\n        \"\"\"Adds the usual set of arguments needed to connect to a server, i.e. `--host`, `--port`, `--user`\n        and `--password` (optional).\n\n        Note that the parser will assume this is a MySQL server.\n\n        Args:\n            prefix: Prefix to add the each argument, e.g. if prefix is `src_`, the arguments will be\n                `--src_host`, etc.\n            include_database: Include `--database` argument.\n            help: Description message to include for this set of arguments.\n\n        \"\"\"\n        group = self.add_argument_group(f\"{prefix}server connection arguments\", description=help)\n        group.add_argument(f\"--{prefix}host\", required=True, metavar=\"HOST\", help=\"host name\")\n        group.add_argument(f\"--{prefix}port\", required=True, type=int, metavar=\"PORT\", help=\"port number\")\n        group.add_argument(f\"--{prefix}user\", required=True, metavar=\"USER\", help=\"user name\")\n        group.add_argument(f\"--{prefix}password\", metavar=\"PWD\", help=\"host password\")\n        if include_database:\n            group.add_argument(f\"--{prefix}database\", required=True, metavar=\"NAME\", help=\"database name\")\n        self.__server_groups.append(prefix)\n\n    def add_log_arguments(self, add_log_file: bool = False) -&gt; None:\n        \"\"\"Adds the usual set of arguments required to set and initialise a logging system.\n\n        The current set includes a mutually exclusive group for the default logging level: `--verbose`,\n        `--debug` or `--log LEVEL`.\n\n        Args:\n            add_log_file: Add arguments to allow storing messages into a file, i.e. `--log_file` and\n                `--log_file_level`.\n\n        \"\"\"\n        # Define the list of log levels available\n        log_levels = [\"DEBUG\", \"INFO\", \"WARNING\", \"ERROR\", \"CRITICAL\"]\n        # NOTE: from 3.11 this list can be changed to: logging.getLevelNamesMapping().keys()\n        # Create logging arguments group\n        group = self.add_argument_group(\"logging arguments\")\n        # Add 3 mutually exclusive options to set the logging level\n        subgroup = group.add_mutually_exclusive_group()\n        subgroup.add_argument(\n            \"-v\",\n            \"--verbose\",\n            action=\"store_const\",\n            const=\"INFO\",\n            dest=\"log_level\",\n            help=\"verbose mode, i.e. 'INFO' log level\",\n        )\n        subgroup.add_argument(\n            \"--debug\",\n            action=\"store_const\",\n            const=\"DEBUG\",\n            dest=\"log_level\",\n            help=\"debugging mode, i.e. 'DEBUG' log level\",\n        )\n        subgroup.add_argument(\n            \"--log\",\n            choices=log_levels,\n            type=str.upper,\n            default=\"WARNING\",\n            metavar=\"LEVEL\",\n            dest=\"log_level\",\n            help=\"level of the events to track: %(choices)s\",\n        )\n        subgroup.set_defaults(log_level=\"WARNING\")\n        if add_log_file:\n            # Add log file-related arguments\n            group.add_argument(\n                \"--log_file\",\n                type=lambda x: self._validate_dst_path(x, exists_ok=True),\n                metavar=\"PATH\",\n                default=None,\n                help=\"log file path\",\n            )\n            group.add_argument(\n                \"--log_file_level\",\n                choices=log_levels,\n                type=str.upper,\n                default=\"DEBUG\",\n                metavar=\"LEVEL\",\n                help=\"level of the events to track in the log file: %(choices)s\",\n            )\n\n    def parse_args(self, *args, **kwargs) -&gt; argparse.Namespace:  # type: ignore[override]\n        \"\"\"Extends the parent function by adding a new URL argument for every server group added.\n\n        The type of this new argument will be `sqlalchemy.engine.URL`. It also logs all the parsed\n        arguments for debugging purposes when logging arguments have been added.\n\n        \"\"\"\n        arguments = super().parse_args(*args, **kwargs)\n        # Build and add an sqlalchemy.engine.URL object for every server group added\n        for prefix in self.__server_groups:\n            # Raise an error rather than overwriting when the URL argument is already present\n            if f\"{prefix}url\" in arguments:\n                self.error(f\"argument '{prefix}url' is already present\")\n            server_url = URL.create(\n                \"mysql\",\n                getattr(arguments, f\"{prefix}user\"),\n                getattr(arguments, f\"{prefix}password\"),\n                getattr(arguments, f\"{prefix}host\"),\n                getattr(arguments, f\"{prefix}port\"),\n                getattr(arguments, f\"{prefix}database\", None),\n            )\n            setattr(arguments, f\"{prefix}url\", server_url)\n        return arguments\n</code></pre>"},{"location":"reference/ensembl/utils/argparse/#ensembl.utils.argparse.ArgumentParser.formatter_class","title":"<code>formatter_class = argparse.ArgumentDefaultsHelpFormatter</code>  <code>instance-attribute</code>","text":""},{"location":"reference/ensembl/utils/argparse/#ensembl.utils.argparse.ArgumentParser.add_argument","title":"<code>add_argument(*args, **kwargs)</code>","text":"<p>Extends the parent function by excluding the default value in the help text when not provided.</p> <p>Only applied to required arguments without a default value, i.e. positional arguments or optional arguments with <code>required=True</code>.</p> Source code in <code>src/ensembl/utils/argparse.py</code> <pre><code>def add_argument(self, *args, **kwargs) -&gt; None:  # type: ignore[override]\n    \"\"\"Extends the parent function by excluding the default value in the help text when not provided.\n\n    Only applied to required arguments without a default value, i.e. positional arguments or optional\n    arguments with `required=True`.\n\n    \"\"\"\n    if kwargs.get(\"required\", False):\n        kwargs.setdefault(\"default\", argparse.SUPPRESS)\n    super().add_argument(*args, **kwargs)\n</code></pre>"},{"location":"reference/ensembl/utils/argparse/#ensembl.utils.argparse.ArgumentParser.add_argument_dst_path","title":"<code>add_argument_dst_path(*args, exists_ok=True, **kwargs)</code>","text":"<p>Adds <code>pathlib.Path</code> argument, checking if it is writable at parsing time.</p> <p>If \"metavar\" is not defined it is added with \"PATH\" as value to improve help text readability.</p> <p>Parameters:</p> Name Type Description Default <code>exists_ok</code> <code>bool</code> <p>Do not raise an error if the destination path already exists.</p> <code>True</code> Source code in <code>src/ensembl/utils/argparse.py</code> <pre><code>def add_argument_dst_path(self, *args, exists_ok: bool = True, **kwargs) -&gt; None:\n    \"\"\"Adds `pathlib.Path` argument, checking if it is writable at parsing time.\n\n    If \"metavar\" is not defined it is added with \"PATH\" as value to improve help text readability.\n\n    Args:\n        exists_ok: Do not raise an error if the destination path already exists.\n\n    \"\"\"\n    kwargs.setdefault(\"metavar\", \"PATH\")\n    kwargs[\"type\"] = lambda x: self._validate_dst_path(x, exists_ok)\n    self.add_argument(*args, **kwargs)\n</code></pre>"},{"location":"reference/ensembl/utils/argparse/#ensembl.utils.argparse.ArgumentParser.add_argument_src_path","title":"<code>add_argument_src_path(*args, **kwargs)</code>","text":"<p>Adds <code>pathlib.Path</code> argument, checking if it exists and it is readable at parsing time.</p> <p>If \"metavar\" is not defined, it is added with \"PATH\" as value to improve help text readability.</p> Source code in <code>src/ensembl/utils/argparse.py</code> <pre><code>def add_argument_src_path(self, *args, **kwargs) -&gt; None:\n    \"\"\"Adds `pathlib.Path` argument, checking if it exists and it is readable at parsing time.\n\n    If \"metavar\" is not defined, it is added with \"PATH\" as value to improve help text readability.\n\n    \"\"\"\n    kwargs.setdefault(\"metavar\", \"PATH\")\n    kwargs[\"type\"] = self._validate_src_path\n    self.add_argument(*args, **kwargs)\n</code></pre>"},{"location":"reference/ensembl/utils/argparse/#ensembl.utils.argparse.ArgumentParser.add_argument_url","title":"<code>add_argument_url(*args, **kwargs)</code>","text":"<p>Adds <code>sqlalchemy.engine.URL</code> argument.</p> <p>If \"metavar\" is not defined it is added with \"URI\" as value to improve help text readability.</p> Source code in <code>src/ensembl/utils/argparse.py</code> <pre><code>def add_argument_url(self, *args, **kwargs) -&gt; None:\n    \"\"\"Adds `sqlalchemy.engine.URL` argument.\n\n    If \"metavar\" is not defined it is added with \"URI\" as value to improve help text readability.\n\n    \"\"\"\n    kwargs.setdefault(\"metavar\", \"URI\")\n    kwargs[\"type\"] = make_url\n    self.add_argument(*args, **kwargs)\n</code></pre>"},{"location":"reference/ensembl/utils/argparse/#ensembl.utils.argparse.ArgumentParser.add_log_arguments","title":"<code>add_log_arguments(add_log_file=False)</code>","text":"<p>Adds the usual set of arguments required to set and initialise a logging system.</p> <p>The current set includes a mutually exclusive group for the default logging level: <code>--verbose</code>, <code>--debug</code> or <code>--log LEVEL</code>.</p> <p>Parameters:</p> Name Type Description Default <code>add_log_file</code> <code>bool</code> <p>Add arguments to allow storing messages into a file, i.e. <code>--log_file</code> and <code>--log_file_level</code>.</p> <code>False</code> Source code in <code>src/ensembl/utils/argparse.py</code> <pre><code>def add_log_arguments(self, add_log_file: bool = False) -&gt; None:\n    \"\"\"Adds the usual set of arguments required to set and initialise a logging system.\n\n    The current set includes a mutually exclusive group for the default logging level: `--verbose`,\n    `--debug` or `--log LEVEL`.\n\n    Args:\n        add_log_file: Add arguments to allow storing messages into a file, i.e. `--log_file` and\n            `--log_file_level`.\n\n    \"\"\"\n    # Define the list of log levels available\n    log_levels = [\"DEBUG\", \"INFO\", \"WARNING\", \"ERROR\", \"CRITICAL\"]\n    # NOTE: from 3.11 this list can be changed to: logging.getLevelNamesMapping().keys()\n    # Create logging arguments group\n    group = self.add_argument_group(\"logging arguments\")\n    # Add 3 mutually exclusive options to set the logging level\n    subgroup = group.add_mutually_exclusive_group()\n    subgroup.add_argument(\n        \"-v\",\n        \"--verbose\",\n        action=\"store_const\",\n        const=\"INFO\",\n        dest=\"log_level\",\n        help=\"verbose mode, i.e. 'INFO' log level\",\n    )\n    subgroup.add_argument(\n        \"--debug\",\n        action=\"store_const\",\n        const=\"DEBUG\",\n        dest=\"log_level\",\n        help=\"debugging mode, i.e. 'DEBUG' log level\",\n    )\n    subgroup.add_argument(\n        \"--log\",\n        choices=log_levels,\n        type=str.upper,\n        default=\"WARNING\",\n        metavar=\"LEVEL\",\n        dest=\"log_level\",\n        help=\"level of the events to track: %(choices)s\",\n    )\n    subgroup.set_defaults(log_level=\"WARNING\")\n    if add_log_file:\n        # Add log file-related arguments\n        group.add_argument(\n            \"--log_file\",\n            type=lambda x: self._validate_dst_path(x, exists_ok=True),\n            metavar=\"PATH\",\n            default=None,\n            help=\"log file path\",\n        )\n        group.add_argument(\n            \"--log_file_level\",\n            choices=log_levels,\n            type=str.upper,\n            default=\"DEBUG\",\n            metavar=\"LEVEL\",\n            help=\"level of the events to track in the log file: %(choices)s\",\n        )\n</code></pre>"},{"location":"reference/ensembl/utils/argparse/#ensembl.utils.argparse.ArgumentParser.add_server_arguments","title":"<code>add_server_arguments(prefix='', include_database=False, help='')</code>","text":"<p>Adds the usual set of arguments needed to connect to a server, i.e. <code>--host</code>, <code>--port</code>, <code>--user</code> and <code>--password</code> (optional).</p> <p>Note that the parser will assume this is a MySQL server.</p> <p>Parameters:</p> Name Type Description Default <code>prefix</code> <code>str</code> <p>Prefix to add the each argument, e.g. if prefix is <code>src_</code>, the arguments will be <code>--src_host</code>, etc.</p> <code>''</code> <code>include_database</code> <code>bool</code> <p>Include <code>--database</code> argument.</p> <code>False</code> <code>help</code> <code>str</code> <p>Description message to include for this set of arguments.</p> <code>''</code> Source code in <code>src/ensembl/utils/argparse.py</code> <pre><code>def add_server_arguments(self, prefix: str = \"\", include_database: bool = False, help: str = \"\") -&gt; None:\n    \"\"\"Adds the usual set of arguments needed to connect to a server, i.e. `--host`, `--port`, `--user`\n    and `--password` (optional).\n\n    Note that the parser will assume this is a MySQL server.\n\n    Args:\n        prefix: Prefix to add the each argument, e.g. if prefix is `src_`, the arguments will be\n            `--src_host`, etc.\n        include_database: Include `--database` argument.\n        help: Description message to include for this set of arguments.\n\n    \"\"\"\n    group = self.add_argument_group(f\"{prefix}server connection arguments\", description=help)\n    group.add_argument(f\"--{prefix}host\", required=True, metavar=\"HOST\", help=\"host name\")\n    group.add_argument(f\"--{prefix}port\", required=True, type=int, metavar=\"PORT\", help=\"port number\")\n    group.add_argument(f\"--{prefix}user\", required=True, metavar=\"USER\", help=\"user name\")\n    group.add_argument(f\"--{prefix}password\", metavar=\"PWD\", help=\"host password\")\n    if include_database:\n        group.add_argument(f\"--{prefix}database\", required=True, metavar=\"NAME\", help=\"database name\")\n    self.__server_groups.append(prefix)\n</code></pre>"},{"location":"reference/ensembl/utils/argparse/#ensembl.utils.argparse.ArgumentParser.parse_args","title":"<code>parse_args(*args, **kwargs)</code>","text":"<p>Extends the parent function by adding a new URL argument for every server group added.</p> <p>The type of this new argument will be <code>sqlalchemy.engine.URL</code>. It also logs all the parsed arguments for debugging purposes when logging arguments have been added.</p> Source code in <code>src/ensembl/utils/argparse.py</code> <pre><code>def parse_args(self, *args, **kwargs) -&gt; argparse.Namespace:  # type: ignore[override]\n    \"\"\"Extends the parent function by adding a new URL argument for every server group added.\n\n    The type of this new argument will be `sqlalchemy.engine.URL`. It also logs all the parsed\n    arguments for debugging purposes when logging arguments have been added.\n\n    \"\"\"\n    arguments = super().parse_args(*args, **kwargs)\n    # Build and add an sqlalchemy.engine.URL object for every server group added\n    for prefix in self.__server_groups:\n        # Raise an error rather than overwriting when the URL argument is already present\n        if f\"{prefix}url\" in arguments:\n            self.error(f\"argument '{prefix}url' is already present\")\n        server_url = URL.create(\n            \"mysql\",\n            getattr(arguments, f\"{prefix}user\"),\n            getattr(arguments, f\"{prefix}password\"),\n            getattr(arguments, f\"{prefix}host\"),\n            getattr(arguments, f\"{prefix}port\"),\n            getattr(arguments, f\"{prefix}database\", None),\n        )\n        setattr(arguments, f\"{prefix}url\", server_url)\n    return arguments\n</code></pre>"},{"location":"reference/ensembl/utils/logging/","title":"logging","text":""},{"location":"reference/ensembl/utils/logging/#ensembl.utils.logging","title":"<code>ensembl.utils.logging</code>","text":"<p>Easy initialisation functionality to set an event logging system.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import logging, pathlib\n&gt;&gt;&gt; from ensembl.utils.logging import init_logging\n&gt;&gt;&gt; logfile = pathlib.Path(\"test.log\")\n&gt;&gt;&gt; init_logging(\"INFO\", logfile, \"DEBUG\")\n&gt;&gt;&gt; logging.info(\"This message is written in both stderr and the log file\")\n&gt;&gt;&gt; logging.debug(\"This message is only written in the log file\")\n</code></pre>"},{"location":"reference/ensembl/utils/logging/#ensembl.utils.logging.LogLevel","title":"<code>LogLevel = Union[int, str]</code>  <code>module-attribute</code>","text":""},{"location":"reference/ensembl/utils/logging/#ensembl.utils.logging.init_logging","title":"<code>init_logging(log_level='WARNING', log_file=None, log_file_level='DEBUG', msg_format='%(asctime)s\\t%(levelname)s\\t%(message)s', date_format='%Y-%m-%d_%H:%M:%S')</code>","text":"<p>Initialises the logging system.</p> <p>By default, all the log messages corresponding to <code>log_level</code> (and above) will be printed in the standard error. If <code>log_file</code> is provided, all messages of <code>log_file_level</code> level (and above) will be written into the provided file.</p> <p>Parameters:</p> Name Type Description Default <code>log_level</code> <code>LogLevel</code> <p>Minimum logging level for the standard error.</p> <code>'WARNING'</code> <code>log_file</code> <code>Optional[StrPath]</code> <p>Logging file where to write logging messages besides the standard error.</p> <code>None</code> <code>log_file_level</code> <code>LogLevel</code> <p>Minimum logging level for the logging file.</p> <code>'DEBUG'</code> <code>msg_format</code> <code>str</code> <p>A format string for the logged output as a whole. More information: https://docs.python.org/3/library/logging.html#logrecord-attributes</p> <code>'%(asctime)s\\t%(levelname)s\\t%(message)s'</code> <code>date_format</code> <code>str</code> <p>A format string for the date/time portion of the logged output. More information: https://docs.python.org/3/library/logging.html#logging.Formatter.formatTime</p> <code>'%Y-%m-%d_%H:%M:%S'</code> Source code in <code>src/ensembl/utils/logging.py</code> <pre><code>def init_logging(\n    log_level: LogLevel = \"WARNING\",\n    log_file: Optional[StrPath] = None,\n    log_file_level: LogLevel = \"DEBUG\",\n    msg_format: str = \"%(asctime)s\\t%(levelname)s\\t%(message)s\",\n    date_format: str = r\"%Y-%m-%d_%H:%M:%S\",\n) -&gt; None:\n    \"\"\"Initialises the logging system.\n\n    By default, all the log messages corresponding to `log_level` (and above) will be printed in the\n    standard error. If `log_file` is provided, all messages of `log_file_level` level (and above) will\n    be written into the provided file.\n\n    Args:\n        log_level: Minimum logging level for the standard error.\n        log_file: Logging file where to write logging messages besides the standard error.\n        log_file_level: Minimum logging level for the logging file.\n        msg_format: A format string for the logged output as a whole. More information:\n            https://docs.python.org/3/library/logging.html#logrecord-attributes\n        date_format: A format string for the date/time portion of the logged output. More information:\n            https://docs.python.org/3/library/logging.html#logging.Formatter.formatTime\n\n    \"\"\"\n    # Configure the basic logging system, setting the root logger to the minimum log level available\n    # to avoid filtering messages in any handler due to \"parent delegation\". Also close and remove any\n    # existing handlers before setting this configuration.\n    logging.basicConfig(format=msg_format, datefmt=date_format, level=\"DEBUG\", force=True)\n    # Set the correct log level of the new StreamHandler (by default it is set to NOTSET)\n    logging.root.handlers[0].setLevel(log_level)\n    if log_file:\n        # Create the log file handler and add it to the root logger\n        formatter = logging.Formatter(msg_format, datefmt=date_format)\n        file_handler = logging.FileHandler(log_file)\n        file_handler.setLevel(log_file_level)\n        file_handler.setFormatter(formatter)\n        logging.root.addHandler(file_handler)\n</code></pre>"},{"location":"reference/ensembl/utils/logging/#ensembl.utils.logging.init_logging_with_args","title":"<code>init_logging_with_args(args)</code>","text":"<p>Processes the Namespace object provided to call <code>init_logging()</code> with the correct arguments.</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>Namespace</code> <p>Namespace populated by an argument parser.</p> required Source code in <code>src/ensembl/utils/logging.py</code> <pre><code>def init_logging_with_args(args: argparse.Namespace) -&gt; None:\n    \"\"\"Processes the Namespace object provided to call `init_logging()` with the correct arguments.\n\n    Args:\n        args: Namespace populated by an argument parser.\n\n    \"\"\"\n    args_dict = vars(args)\n    log_args = {x: args_dict[x] for x in [\"log_level\", \"log_file\", \"log_file_level\"] if x in args_dict}\n    init_logging(**log_args)\n</code></pre>"},{"location":"reference/ensembl/utils/rloader/","title":"rloader","text":""},{"location":"reference/ensembl/utils/rloader/#ensembl.utils.rloader","title":"<code>ensembl.utils.rloader</code>","text":"<p>Allow to seamlessly load / read the content of a remote file as if it was located locally.</p>"},{"location":"reference/ensembl/utils/rloader/#ensembl.utils.rloader.logger","title":"<code>logger = logging.getLogger(__name__)</code>  <code>module-attribute</code>","text":""},{"location":"reference/ensembl/utils/rloader/#ensembl.utils.rloader.RemoteFileLoader","title":"<code>RemoteFileLoader</code>","text":"<p>Loads remote files, allowing specific format parsing options.</p> <p>Parameters:</p> Name Type Description Default <code>parser</code> <code>Optional[str]</code> <p>Parser to use for this object. Default: <code>None</code> (no format-specific parsing done).</p> <code>None</code> <p>Attributes:</p> Name Type Description <code>available_formats</code> <code>set[str]</code> <p>File formats with ad-hoc parsers available.</p> <code>parser</code> <code>Optional[str]</code> <p>Parser selected for this object.</p> Source code in <code>src/ensembl/utils/rloader.py</code> <pre><code>class RemoteFileLoader:\n    \"\"\"Loads remote files, allowing specific format parsing options.\n\n    Args:\n        parser: Parser to use for this object. Default: `None` (no format-specific parsing done).\n\n    Attributes:\n        available_formats: File formats with ad-hoc parsers available.\n        parser: Parser selected for this object.\n\n    \"\"\"\n\n    available_formats: set[str] = {\"yaml\", \"ini\", \"env\", \"json\"}\n    parser: Optional[str] = None\n\n    def __init__(self, parser: Optional[str] = None) -&gt; None:\n        if parser in self.available_formats:\n            self.parser = parser\n\n    def __parse(self, content: str) -&gt; Any:\n        if self.parser == \"yaml\":\n            return yaml.load(content, yaml.SafeLoader)\n        if self.parser == \"ini\":\n            config = configparser.ConfigParser()\n            try:\n                config.read_string(content)\n            except configparser.MissingSectionHeaderError:\n                content = \"[DEFAULT]\\n\" + content\n                config.read_string(content)\n            return config\n        if self.parser == \"env\":\n            return dotenv.dotenv_values(stream=StringIO(content))\n        if self.parser == \"json\":\n            return json.loads(content)\n        # Only return content, no parsing\n        return content\n\n    def r_open(self, url: str) -&gt; Any:\n        \"\"\"Returns the parsed remote file from the given URL.\n\n        Args:\n            url: URL of the remote file to fetch.\n\n        Raises:\n            requests.exception.HTTPError: If loading or requesting the given URL returned an error.\n            requests.exception.Timeout: If a timeout was raised whilst requesting the given URL.\n\n        \"\"\"\n        try:\n            r = requests.get(url, timeout=120)\n            if r.status_code == 200:\n                return self.__parse(r.text)\n            raise requests.exceptions.HTTPError(response=r)\n        except requests.exceptions.HTTPError as ex:\n            logger.exception(f\"Error with request to {url}: {ex}\")\n            raise ex\n        except requests.exceptions.Timeout as ex:\n            logger.exception(f\"Request timed out {url}: {ex}\")\n            raise ex\n</code></pre>"},{"location":"reference/ensembl/utils/rloader/#ensembl.utils.rloader.RemoteFileLoader.available_formats","title":"<code>available_formats: set[str] = {'yaml', 'ini', 'env', 'json'}</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/ensembl/utils/rloader/#ensembl.utils.rloader.RemoteFileLoader.parser","title":"<code>parser: Optional[str] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/ensembl/utils/rloader/#ensembl.utils.rloader.RemoteFileLoader.r_open","title":"<code>r_open(url)</code>","text":"<p>Returns the parsed remote file from the given URL.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>URL of the remote file to fetch.</p> required <p>Raises:</p> Type Description <code>HTTPError</code> <p>If loading or requesting the given URL returned an error.</p> <code>Timeout</code> <p>If a timeout was raised whilst requesting the given URL.</p> Source code in <code>src/ensembl/utils/rloader.py</code> <pre><code>def r_open(self, url: str) -&gt; Any:\n    \"\"\"Returns the parsed remote file from the given URL.\n\n    Args:\n        url: URL of the remote file to fetch.\n\n    Raises:\n        requests.exception.HTTPError: If loading or requesting the given URL returned an error.\n        requests.exception.Timeout: If a timeout was raised whilst requesting the given URL.\n\n    \"\"\"\n    try:\n        r = requests.get(url, timeout=120)\n        if r.status_code == 200:\n            return self.__parse(r.text)\n        raise requests.exceptions.HTTPError(response=r)\n    except requests.exceptions.HTTPError as ex:\n        logger.exception(f\"Error with request to {url}: {ex}\")\n        raise ex\n    except requests.exceptions.Timeout as ex:\n        logger.exception(f\"Request timed out {url}: {ex}\")\n        raise ex\n</code></pre>"},{"location":"coverage/","title":"Coverage report","text":""}]}